import discord
from discord.ext import commands, tasks
import json
import os
import asyncio
import string
import random
from datetime import datetime, timedelta
import aiofiles

# Bot configuration
intents = discord.Intents.default()
intents.message_content = True
bot = commands.Bot(command_prefix='!', intents=intents)

# Data file path
DATA_FILE = 'bot_data.json'

# Channel configuration - Updated as requested
CHANNELS = {
    'daily_claims': 1386661611506237480,
    'point_drops': 1386661687356030976,
    'leaderboard': 1386368897447493783,
    'transfers': 1386365076268908564,
    'gambling': 1386724089980387522,
    'general': None  # Can be set to allow leaderboard from general channel
}

# Gift card options
GIFT_CARDS = {
    'steam': {'name': 'Steam Gift Card', 'cost': 1000, 'emoji': 'üéÆ'},
    'amazon': {'name': 'Amazon Gift Card', 'cost': 1500, 'emoji': 'üì¶'},
    'spotify': {'name': 'Spotify Premium', 'cost': 800, 'emoji': 'üéµ'},
    'netflix': {'name': 'Netflix Subscription', 'cost': 1200, 'emoji': 'üé¨'},
    'google': {'name': 'Google Play Card', 'cost': 900, 'emoji': 'üì±'}
}

class PointsBot:
    def __init__(self):
        self.data = {
            'users': {},
            'settings': {
                'daily_reward': 50,
                'max_streak_multiplier': 3.0,
                'conversion_rate': 100,
                'drop_channel_id': None
            },
            'gift_card_requests': {}
        }
        self.load_data()

    async def save_data(self):
        """Save data to JSON file asynchronously"""
        try:
            async with aiofiles.open(DATA_FILE, 'w') as f:
                await f.write(json.dumps(self.data, indent=2, default=str))
        except Exception as e:
            print(f"Error saving data: {e}")

    def load_data(self):
        """Load data from JSON file"""
        try:
            if os.path.exists(DATA_FILE):
                with open(DATA_FILE, 'r') as f:
                    loaded_data = json.load(f)
                    self.data.update(loaded_data)
                print(f"Loaded data for {len(self.data['users'])} users")
            else:
                print("No existing data file found, starting fresh")
        except Exception as e:
            print(f"Error loading data: {e}")

    def get_user_data(self, user_id):
        """Get user data, create if doesn't exist"""
        user_id = str(user_id)
        if user_id not in self.data['users']:
            self.data['users'][user_id] = {
                'points': 0,
                'last_claim': None,
                'streak': 0,
                'total_earned': 0,
                'total_spent': 0,
                'inventory': [],
                'gift_cards_redeemed': []
            }
        return self.data['users'][user_id]

    def calculate_streak_multiplier(self, streak):
        """Calculate multiplier based on streak"""
        max_multiplier = self.data['settings']['max_streak_multiplier']
        return min(1 + (streak * 0.1), max_multiplier)

# Initialize points system
points_system = PointsBot()

# View Classes
class DailyClaimView(discord.ui.View):
    def __init__(self, timeout=86400):  # 24 hours timeout
        super().__init__(timeout=timeout)

    @discord.ui.button(label='Claim Daily Diamonds', style=discord.ButtonStyle.success, emoji='üíé')
    async def claim_daily_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        user_data = points_system.get_user_data(interaction.user.id)
        now = datetime.now()

        if user_data['last_claim']:
            last_claim = datetime.fromisoformat(user_data['last_claim'])
            time_diff = now - last_claim

            if time_diff < timedelta(hours=24):
                next_claim = last_claim + timedelta(hours=24)
                embed = discord.Embed(
                    title="‚è∞ Daily Claim Cooldown",
                    description=f"You can claim again <t:{int(next_claim.timestamp())}:R>",
                    color=discord.Color.red()
                )
                await interaction.response.send_message(embed=embed, ephemeral=True)
                return

            if time_diff <= timedelta(hours=36):
                user_data['streak'] += 1
            else:
                user_data['streak'] = 1
        else:
            user_data['streak'] = 1

        base_reward = points_system.data['settings']['daily_reward']
        multiplier = points_system.calculate_streak_multiplier(user_data['streak'])
        total_reward = int(base_reward * multiplier)

        user_data['points'] += total_reward
        user_data['total_earned'] += total_reward
        user_data['last_claim'] = now.isoformat()

        embed = discord.Embed(
            title="üíé Daily Diamond Claim!",
            description=f"**Reward:** {total_reward} üíé\n{interaction.user.mention} claimed their daily diamonds!",
            color=discord.Color.gold()
        )
        embed.add_field(name="üí∞ Reward", value=f"{total_reward} üíé", inline=True)
        embed.add_field(name="üî• Streak", value=f"{user_data['streak']} days", inline=True)
        embed.add_field(name="üìà Multiplier", value=f"{multiplier:.1f}x", inline=True)

        await interaction.response.send_message(embed=embed, ephemeral=False)
        await points_system.save_data()

class DiceFormModal(discord.ui.Modal, title='üé≤ Dice Game Setup'):
    def __init__(self):
        super().__init__()

    guess = discord.ui.TextInput(
        label='Your Guess (1-6)',
        placeholder='Enter a number between 1 and 6...',
        required=True,
        max_length=1
    )

    bet_amount = discord.ui.TextInput(
        label='Bet Amount (Minimum 10 Diamonds)',
        placeholder='Enter your bet amount (min 10)...',
        required=True,
        max_length=10
    )

    async def on_submit(self, interaction: discord.Interaction):
        try:
            # Validate and convert inputs
            guess_input = self.guess.value.strip()
            bet_input = self.bet_amount.value.strip()
            
            if not guess_input.isdigit():
                await interaction.response.send_message("‚ùå Please enter a valid number for your guess (1-6)!", ephemeral=True)
                return
                
            if not bet_input.isdigit():
                await interaction.response.send_message("‚ùå Please enter a valid number for your bet amount!", ephemeral=True)
                return
            
            guess_num = int(guess_input)
            bet = int(bet_input)

            if guess_num < 1 or guess_num > 6:
                await interaction.response.send_message("‚ùå Guess must be between 1 and 6!", ephemeral=True)
                return

            if bet < 10:
                await interaction.response.send_message("‚ùå Minimum bet is 10 diamonds!", ephemeral=True)
                return

            user_data = points_system.get_user_data(interaction.user.id)

            if user_data['points'] < bet:
                await interaction.response.send_message(f"‚ùå Insufficient points! You have {user_data['points']} üíé but need {bet} üíé", ephemeral=True)
                return

            result = random.randint(1, 6)
            won = guess_num == result

            dice_faces = {
                1: "‚öÄ", 2: "‚öÅ", 3: "‚öÇ", 
                4: "‚öÉ", 5: "‚öÑ", 6: "‚öÖ"
            }

            if won:
                winnings = bet * 5
                user_data['points'] += winnings
                user_data['total_earned'] += winnings
                color = discord.Color.green()
                title = "üé≤ LUCKY DICE! You Won!"
                result_text = f"**Your Guess:** {guess_num} {dice_faces[guess_num]} ‚úÖ\n**Dice Result:** {result} {dice_faces[result]}\n**Won:** {winnings} üíé (5x multiplier!)"
            else:
                user_data['points'] -= bet
                user_data['total_spent'] += bet
                color = discord.Color.red()
                title = "üé≤ Dice Roll - Try Again!"
                result_text = f"**Your Guess:** {guess_num} {dice_faces[guess_num]} ‚ùå\n**Dice Result:** {result} {dice_faces[result]}\n**Lost:** {bet} üíé"

            embed = discord.Embed(
                title=title,
                description=f"**üé≤ Dice Game Result üé≤**\n{result_text}",
                color=color
            )
            embed.add_field(name="üí∞ New Balance", value=f"{user_data['points']} üíé", inline=True)
            embed.add_field(name="üéØ Bet Amount", value=f"{bet} üíé", inline=True)

            await interaction.response.send_message(embed=embed, ephemeral=False)
            await points_system.save_data()

        except ValueError:
            await interaction.response.send_message("‚ùå Please enter valid numbers only! Check your guess (1-6) and bet amount.", ephemeral=True)
        except Exception as e:
            await interaction.response.send_message(f"‚ùå An error occurred: {str(e)}", ephemeral=True)

class CoinflipFormModal(discord.ui.Modal, title='ü™ô Coinflip Game Setup'):
    def __init__(self):
        super().__init__()

    choice = discord.ui.TextInput(
        label='Your Choice (heads/tails or H/T)',
        placeholder='Enter heads, tails, H, or T...',
        required=True,
        max_length=5
    )

    bet_amount = discord.ui.TextInput(
        label='Bet Amount (Minimum 10 Diamonds)',
        placeholder='Enter your bet amount (min 10)...',
        required=True,
        max_length=10
    )

    async def on_submit(self, interaction: discord.Interaction):
        try:
            user_input = self.choice.value.strip()
            bet_input = self.bet_amount.value.strip()
            
            # Validate bet amount input
            if not bet_input.isdigit():
                await interaction.response.send_message("‚ùå Please enter a valid number for your bet amount!", ephemeral=True)
                return
            
            bet = int(bet_input)
            
            # Convert user input to full form (accept H/T shortcuts)
            user_input_lower = user_input.lower()
            if user_input_lower in ['heads', 'h']:
                user_choice = 'heads'
            elif user_input_lower in ['tails', 't']:
                user_choice = 'tails'
            else:
                await interaction.response.send_message("‚ùå Choice must be 'heads', 'tails', 'H', or 'T'!\n**Suggestions:** H (Heads) or T (Tails)", ephemeral=True)
                return

            if bet < 10:
                await interaction.response.send_message("‚ùå Minimum bet is 10 diamonds!", ephemeral=True)
                return

            user_data = points_system.get_user_data(interaction.user.id)

            if user_data['points'] < bet:
                await interaction.response.send_message(f"‚ùå Insufficient points! You have {user_data['points']} üíé", ephemeral=True)
                return

            result = random.choice(['heads', 'tails'])
            won = user_choice == result

            choice_icons = {'heads': 'üëë', 'tails': 'üí∞'}
            choice_letters = {'heads': 'H', 'tails': 'T'}

            if won:
                winnings = bet * 2
                user_data['points'] += winnings
                user_data['total_earned'] += winnings
                color = discord.Color.green()
                title = "ü™ô PERFECT FLIP! You Won!"
                result_text = f"**Your Choice:** {choice_letters[user_choice]} ({user_choice.title()}) {choice_icons[user_choice]} ‚úÖ\n**Coin Result:** {choice_letters[result]} ({result.title()}) {choice_icons[result]}\n**Won:** {winnings} üíé (2x multiplier!)"
            else:
                user_data['points'] -= bet
                user_data['total_spent'] += bet
                color = discord.Color.red()
                title = "ü™ô Coin Flip - Next Time!"
                result_text = f"**Your Choice:** {choice_letters[user_choice]} ({user_choice.title()}) {choice_icons[user_choice]} ‚ùå\n**Coin Result:** {choice_letters[result]} ({result.title()}) {choice_icons[result]}\n**Lost:** {bet} üíé"

            embed = discord.Embed(
                title=title,
                description=f"**ü™ô Coinflip Game Result ü™ô**\n{result_text}",
                color=color
            )
            embed.add_field(name="üí∞ New Balance", value=f"{user_data['points']} üíé", inline=True)
            embed.add_field(name="üéØ Bet Amount", value=f"{bet} üíé", inline=True)

            await interaction.response.send_message(embed=embed, ephemeral=False)
            await points_system.save_data()

        except ValueError:
            await interaction.response.send_message("‚ùå Please enter valid inputs! Check your choice (H/T or heads/tails) and bet amount.", ephemeral=True)
        except Exception as e:
            await interaction.response.send_message(f"‚ùå An error occurred: {str(e)}", ephemeral=True)

class GamblingView(discord.ui.View):
    def __init__(self, timeout=300):
        super().__init__(timeout=timeout)

    @discord.ui.button(label='üé≤ Dice Game', style=discord.ButtonStyle.primary, emoji='üé≤')
    async def quick_dice(self, interaction: discord.Interaction, button: discord.ui.Button):
        modal = DiceFormModal()
        await interaction.response.send_modal(modal)

    @discord.ui.button(label='ü™ô Coinflip Game', style=discord.ButtonStyle.success, emoji='ü™ô')
    async def quick_coinflip(self, interaction: discord.Interaction, button: discord.ui.Button):
        modal = CoinflipFormModal()
        await interaction.response.send_modal(modal)

    @discord.ui.button(label='üé∞ Lucky Slots', style=discord.ButtonStyle.danger, emoji='üé∞')
    async def quick_slots(self, interaction: discord.Interaction, button: discord.ui.Button):
        user_data = points_system.get_user_data(interaction.user.id)
        bet = 30

        if user_data['points'] < bet:
            await interaction.response.send_message(f"‚ùå You need {bet} üíé to play! You have {user_data['points']} üíé", ephemeral=True)
            return

        symbols = ['üçí', 'üçã', 'üçä', 'üíé', '‚≠ê', 'üçÄ']
        weights = [30, 25, 20, 15, 8, 2]

        reels = [random.choices(symbols, weights=weights)[0] for _ in range(3)]

        multiplier = 0
        if reels[0] == reels[1] == reels[2]:
            if reels[0] == 'üíé': multiplier = 10
            elif reels[0] == '‚≠ê': multiplier = 8
            elif reels[0] == 'üçÄ': multiplier = 12
            else: multiplier = 3
        elif reels[0] == reels[1] or reels[1] == reels[2] or reels[0] == reels[2]:
            multiplier = 1.5

        winnings = int(bet * multiplier) if multiplier > 0 else 0

        if winnings > 0:
            user_data['points'] += winnings - bet
            user_data['total_earned'] += winnings
            color = discord.Color.green()
            title = "üé∞ JACKPOT!" if multiplier >= 8 else "üé∞ Slots Winner!"
            result_text = f"**Won:** {winnings} üíé ({multiplier}x!)"
        else:
            user_data['points'] -= bet
            user_data['total_spent'] += bet
            color = discord.Color.red()
            title = "üé∞ Slots - Spin Again!"
            result_text = f"**Lost:** {bet} üíé"

        embed = discord.Embed(
            title=title,
            description=f"**Slot Result:** {reels[0]} {reels[1]} {reels[2]}\n{result_text}",
            color=color
        )
        embed.add_field(name="üí∞ Balance", value=f"{user_data['points']} üíé", inline=True)

        await interaction.response.send_message(embed=embed, ephemeral=False)
        await points_system.save_data()

    @discord.ui.button(label='üìä Game Details', style=discord.ButtonStyle.secondary, emoji='üìä', row=1)
    async def game_details(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(
            title="üéÆ Casino Games Details",
            description="**Choose Your Stakes!**",
            color=discord.Color.blue()
        )

        embed.add_field(
            name="üé≤ Dice Game",
            value="‚Ä¢ Choose number 1-6\n‚Ä¢ Minimum bet: 10 üíé\n‚Ä¢ Win: 5x your bet\n‚Ä¢ Form opens on click",
            inline=True
        )

        embed.add_field(
            name="ü™ô Coinflip Game",
            value="‚Ä¢ Pick H/T or heads/tails\n‚Ä¢ Minimum bet: 10 üíé\n‚Ä¢ Win: 2x your bet\n‚Ä¢ Form opens on click",
            inline=True
        )

        embed.add_field(
            name="üé∞ Lucky Slots",
            value="‚Ä¢ Auto-spin reels\n‚Ä¢ Set your own bet\n‚Ä¢ Win: Up to 12x bet\n‚Ä¢ Instant play",
            inline=True
        )

        await interaction.response.send_message(embed=embed, ephemeral=True)

class PointDropView(discord.ui.View):
    def __init__(self, timeout=360):
        super().__init__(timeout=timeout)
        self.is_active = False
        self.claimed_users = set()

    @discord.ui.button(label='Waiting to Start...', style=discord.ButtonStyle.gray, emoji='‚è≥', disabled=True)
    async def claim_points(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not self.is_active:
            await interaction.response.send_message("‚ùå The claiming period hasn't started yet! Wait for the countdown to finish.", ephemeral=True)
            return

        if interaction.user.id in self.claimed_users:
            await interaction.response.send_message("‚ùå You've already claimed from this drop!", ephemeral=True)
            return

        self.claimed_users.add(interaction.user.id)
        user_data = points_system.get_user_data(interaction.user.id)
        user_data['points'] += 10
        user_data['total_earned'] += 10

        await interaction.response.send_message(f"‚úÖ {interaction.user.mention} claimed 10 Diamonds! Total claimed: {len(self.claimed_users)} users", ephemeral=False)
        await points_system.save_data()

    async def start_countdown(self, message):
        self.message = message

        for remaining in range(300, 0, -30):
            minutes = remaining // 60
            seconds = remaining % 60

            embed = discord.Embed(
                title="‚è≥ Point Drop Starting Soon!",
                description=f"Get ready! Claiming starts in **{minutes}m {seconds}s**\n\nEach claim gives **10 Diamonds**! üíé",
                color=discord.Color.orange()
            )

            try:
                await message.edit(embed=embed, view=self)
                await asyncio.sleep(30)
            except:
                return

        await self.start_claiming()

    async def start_claiming(self):
        self.is_active = True
        button = self.children[0]
        button.label = 'Claim 10 Diamonds!'
        button.style = discord.ButtonStyle.success
        button.disabled = False
        button.emoji = 'üíé'

        embed = discord.Embed(
            title="üöÄ Point Drop Active!",
            description="**3D Active Animation:**\n```\n‚ú® ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ ‚ú®\n  ‚ï± üíéüíéüíé ‚ï±\n ‚ï± üíéüíéüíé ‚ï±\n‚ï± üíéüíéüíé ‚ï±\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n```\n**Claiming is now LIVE!**\nClick to claim 10 Diamonds!",
            color=discord.Color.green()
        )

        try:
            await self.message.edit(embed=embed, view=self)
        except:
            pass

        for remaining in range(60, 0, -10):
            await asyncio.sleep(10)
            embed.add_field(name="‚è∞ Time Left", value=f"{remaining}s", inline=True)
            embed.add_field(name="üë• Claims", value=f"{len(self.claimed_users)}", inline=True)

            try:
                await self.message.edit(embed=embed, view=self)
                embed.clear_fields()
            except:
                break

        await self.end_claiming()

    async def end_claiming(self):
        self.is_active = False
        button = self.children[0]
        button.label = 'Claiming Ended'
        button.style = discord.ButtonStyle.gray
        button.disabled = True
        button.emoji = '‚è∞'

        embed = discord.Embed(
            title="üèÅ Point Drop Finished!",
            description=f"**Final Results:**\n```\nüèÜ {len(self.claimed_users)} Winners!\nüíé {len(self.claimed_users) * 10} Total Distributed\n```\nClaiming period has ended!",
            color=discord.Color.blue()
        )

        try:
            await self.message.edit(embed=embed, view=self)
        except:
            pass

class GiftCardView(discord.ui.View):
    def __init__(self, timeout=300):
        super().__init__(timeout=timeout)

    @discord.ui.select(
        placeholder="üéÅ Choose a gift card to redeem...",
        options=[
            discord.SelectOption(
                label=f"{card['name']} - {cost} üíé",
                description=f"Cost: {cost} Diamonds",
                emoji=card['emoji'],
                value=card_type
            )
            for card_type, card in GIFT_CARDS.items()
            for cost in [card['cost']]
        ]
    )
    async def select_gift_card(self, interaction: discord.Interaction, select: discord.ui.Select):
        card_type = select.values[0]
        card = GIFT_CARDS[card_type]
        user_data = points_system.get_user_data(interaction.user.id)

        if user_data['points'] < card['cost']:
            embed = discord.Embed(
                title="‚ùå Insufficient Diamonds",
                description=f"You need {card['cost']} üíé but only have {user_data['points']} üíé",
                color=discord.Color.red()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        # Deduct points
        user_data['points'] -= card['cost']
        user_data['total_spent'] += card['cost']
        user_data['gift_cards_redeemed'].append({
            'type': card_type,
            'name': card['name'],
            'cost': card['cost'],
            'date': datetime.now().isoformat()
        })

        # Send DM to user
        try:
            dm_embed = discord.Embed(
                title="üéâ Gift Card Redeemed Successfully!",
                description=f"**{card['name']}** has been redeemed!\n\n**Details:**\n‚Ä¢ Cost: {card['cost']} üíé\n‚Ä¢ Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n‚Ä¢ Remaining Diamonds: {user_data['points']} üíé",
                color=discord.Color.green()
            )
            dm_embed.add_field(
                name="üìß Next Steps",
                value="An administrator will contact you within 24 hours to process your gift card delivery. Please keep this message for reference.",
                inline=False
            )
            dm_embed.set_footer(text="Thank you for using our points system!")

            await interaction.user.send(embed=dm_embed)
            dm_sent = True
        except:
            dm_sent = False

        # Store request for admin processing
        points_system.data['gift_card_requests'][str(interaction.user.id)] = {
            'user_id': interaction.user.id,
            'username': interaction.user.display_name,
            'card_type': card_type,
            'card_name': card['name'],
            'cost': card['cost'],
            'timestamp': datetime.now().isoformat(),
            'status': 'pending'
        }

        # Response embed
        embed = discord.Embed(
            title="‚úÖ Gift Card Redeemed!",
            description=f"Successfully redeemed **{card['name']}**!",
            color=discord.Color.green()
        )
        embed.add_field(name="Cost", value=f"{card['cost']} üíé", inline=True)
        embed.add_field(name="Remaining", value=f"{user_data['points']} üíé", inline=True)

        if dm_sent:
            embed.add_field(name="üìß Check DM", value="Details sent to your DM!", inline=False)
        else:
            embed.add_field(name="‚ö†Ô∏è DM Failed", value="Couldn't send DM. Please enable DMs from server members.", inline=False)

        await interaction.response.send_message(embed=embed, ephemeral=True)
        await points_system.save_data()

@bot.event
async def on_ready():
    print(f'{bot.user} has connected to Discord!')
    print(f'Bot is in {len(bot.guilds)} guilds')

    try:
        synced = await bot.tree.sync()
        print(f"Synced {len(synced)} command(s)")
    except Exception as e:
        print(f"Failed to sync commands: {e}")

    auto_save.start()
    auto_daily_claims.start()

    # Send initial panels when bot starts
    await send_startup_panels()

@tasks.loop(minutes=5)
async def auto_save():
    await points_system.save_data()

@tasks.loop(hours=24)
async def auto_daily_claims():
    daily_channel = bot.get_channel(CHANNELS['daily_claims'])
    if not daily_channel:
        print("Daily claims channel not found!")
        return

    # Clean old daily claim messages
    await cleanup_old_messages(daily_channel, bot.user.id)

    embed = discord.Embed(
        title="üíé 24H Daily Diamond Claim Refresh!",
        description="**Daily Diamond Reward:**\n```\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë   üíé 50   ‚ïë\n‚ïë  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó  ‚ïë\n‚ïë  ‚ïë ‚ú® ‚ú® ‚ïë  ‚ïë\n‚ïë  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n```\n**Fresh 24H claim period started!**\n\nClick the button below to claim your diamonds and maintain your streak!",
        color=discord.Color.gold()
    )
    embed.add_field(name="üí∞ Base Reward", value="50 üíé", inline=True)
    embed.add_field(name="üî• Streak Bonus", value="Up to 3x multiplier!", inline=True)
    embed.add_field(name="‚è∞ Auto Refresh", value="Every 24 hours", inline=True)
    embed.set_footer(text="üîÑ 24H Auto-refresh active")

    view = DailyClaimView()
    await daily_channel.send(embed=embed, view=view)

async def cleanup_old_messages(channel, bot_user_id, limit=50):
    """Remove old bot messages from a channel"""
    try:
        deleted_count = 0
        async for message in channel.history(limit=limit):
            if message.author.id == bot_user_id:
                await message.delete()
                deleted_count += 1
                await asyncio.sleep(0.5)  # Rate limit protection
        if deleted_count > 0:
            print(f"üßπ Cleaned {deleted_count} old messages from #{channel.name}")
    except Exception as e:
        print(f"‚ö†Ô∏è Couldn't clean messages in #{channel.name}: {e}")

async def send_startup_panels():
    """Send all interactive panels when bot starts"""
    await asyncio.sleep(10)  # Wait for bot to fully initialize

    # Clean up old messages and send new ones
    
    # Daily claims panel - cleanup and send new
    daily_channel = bot.get_channel(CHANNELS['daily_claims'])
    if daily_channel:
        await cleanup_old_messages(daily_channel, bot.user.id)
        
        embed = discord.Embed(
            title="üíé 24H Daily Diamond Claim Center",
            description="**Daily Diamond Reward:**\n```\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë   üíé 50   ‚ïë\n‚ïë  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó  ‚ïë\n‚ïë  ‚ïë ‚ú® ‚ú® ‚ïë  ‚ïë\n‚ïë  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n```\n**Your daily diamonds are ready!**\n\nClick the button below to claim your diamonds and maintain your streak!",
            color=discord.Color.gold()
        )
        embed.add_field(name="üí∞ Base Reward", value="50 üíé", inline=True)
        embed.add_field(name="üî• Streak Bonus", value="Up to 3x multiplier!", inline=True)
        embed.add_field(name="‚è∞ Auto Refresh", value="Every 24 hours", inline=True)
        embed.set_footer(text="ü§ñ Auto-started by bot")

        view = DailyClaimView()
        await daily_channel.send(embed=embed, view=view)
        print("‚úÖ Daily claim panel sent on startup")

    # Leaderboard Panel - cleanup and send new
    leaderboard_channel = bot.get_channel(CHANNELS['leaderboard'])
    if leaderboard_channel:
        await cleanup_old_messages(leaderboard_channel, bot.user.id)
        
        users_data = points_system.data['users']
        sorted_users = sorted(users_data.items(), key=lambda x: x[1]['points'], reverse=True)[:10]

        embed = discord.Embed(
            title="üèÜ 24H Diamond Leaderboard",
            description="**Top 10 Richest Players**\n```\n    üèÜ LEADERBOARD üèÜ\n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n  ‚ïë üëë DIAMOND ELITE üëë ‚ïë\n  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n```",
            color=discord.Color.gold()
        )

        medals = ["ü•á", "ü•à", "ü•â"]
        trophy_design = ["üëë", "üíé", "‚≠ê"]

        for i, (user_id, data) in enumerate(sorted_users[:5], 1):  # Show top 5 on startup
            try:
                user = bot.get_user(int(user_id))
                user_display = f"@{user.name}" if user else f"User {user_id}"
            except:
                user_display = f"User {user_id}"

            if i <= 3:
                position_emoji = medals[i-1]
                decoration = trophy_design[i-1]
            else:
                position_emoji = f"{i}."
                decoration = "üíé"

            embed.add_field(
                name=f"{position_emoji} {user_display}",
                value=f"{decoration} {data['points']:,} Diamonds\nüî• {data['streak']} day streak",
                inline=False
            )

        embed.set_footer(text="ü§ñ Auto-updated every 24H | Use /leaderboard for full list")
        await leaderboard_channel.send(embed=embed)
        print("‚úÖ Leaderboard sent on startup")

    # Send gambling panel (no cleanup needed as it's less frequent)
    gambling_channel = bot.get_channel(CHANNELS['gambling'])
    if gambling_channel:
        embed = discord.Embed(
            title="üé∞ Diamond Casino - Gambling Hub",
            description="**Welcome to the Casino!**\n```\nüé≤ ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó ü™ô\n  ‚ïë  CASINO   ‚ïë\n  ‚ïë ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ‚ïë\n  ‚ïë üíé GAMES üíé ‚ïë\n  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n```\n**Available Games:**",
            color=discord.Color.purple()
        )
        embed.add_field(name="üé≤ Quick Dice", value="Guess 1-6 for 5x payout!\nFill form with number & bet", inline=True)
        embed.add_field(name="ü™ô Quick Flip", value="Heads or Tails for 2x payout!\nFill form with choice & bet", inline=True)
        embed.add_field(name="üíé Risk & Reward", value="Higher risk = Higher rewards!", inline=False)
        embed.set_footer(text="üé∞ Good luck and gamble responsibly!")

        view = GamblingView()
        await gambling_channel.send(embed=embed, view=view)

@auto_daily_claims.before_loop
async def before_auto_daily_claims():
    await bot.wait_until_ready()
    # Calculate time until next midnight (00:00)
    now = datetime.now()
    next_midnight = (now + timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0)
    seconds_until_midnight = (next_midnight - now).total_seconds()
    await asyncio.sleep(seconds_until_midnight)

# Slash Commands
@bot.tree.command(name="claim_daily", description="Claim your daily reward and streak bonus")
async def claim_daily(interaction: discord.Interaction):
    if interaction.channel_id != CHANNELS['daily_claims']:
        embed = discord.Embed(
            title="‚ùå Wrong Channel",
            description=f"Please use this command in <#{CHANNELS['daily_claims']}>",
            color=discord.Color.red()
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)
        return

    user_data = points_system.get_user_data(interaction.user.id)
    now = datetime.now()

    if user_data['last_claim']:
        last_claim = datetime.fromisoformat(user_data['last_claim'])
        time_diff = now - last_claim

        if time_diff < timedelta(hours=24):
            next_claim = last_claim + timedelta(hours=24)
            embed = discord.Embed(
                title="‚è∞ Daily Claim Cooldown",
                description=f"You can claim again <t:{int(next_claim.timestamp())}:R>",
                color=discord.Color.red()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        if time_diff <= timedelta(hours=36):
            user_data['streak'] += 1
        else:
            user_data['streak'] = 1
    else:
        user_data['streak'] = 1

    base_reward = points_system.data['settings']['daily_reward']
    multiplier = points_system.calculate_streak_multiplier(user_data['streak'])
    total_reward = int(base_reward * multiplier)

    user_data['points'] += total_reward
    user_data['total_earned'] += total_reward
    user_data['last_claim'] = now.isoformat()

    embed = discord.Embed(
        title="üíé Daily Diamond Claim!",
        description=f"**Reward:** {total_reward} üíé\n{interaction.user.mention} claimed their daily diamonds!",
        color=discord.Color.gold()
    )
    embed.add_field(name="üí∞ Reward", value=f"{total_reward} üíé", inline=True)
    embed.add_field(name="üî• Streak", value=f"{user_data['streak']} days", inline=True)
    embed.add_field(name="üìà Multiplier", value=f"{multiplier:.1f}x", inline=True)

    await interaction.response.send_message(embed=embed)
    await points_system.save_data()

@bot.tree.command(name="get_points", description="Check your points or another user's points")
async def get_points(interaction: discord.Interaction, user: discord.Member = None):
    if interaction.channel_id != CHANNELS['transfers']:
        embed = discord.Embed(
            title="‚ùå Wrong Channel",
            description=f"Please use this command in <#{CHANNELS['transfers']}>",
            color=discord.Color.red()
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)
        return

    target_user = user or interaction.user
    user_data = points_system.get_user_data(target_user.id)

    embed = discord.Embed(
        title=f"üíé {target_user.display_name}'s Points",
        description=f"**3D Wallet:**\n```\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë üíé {user_data['points']:,} Diamonds ‚ïë\n‚ïë‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïë\n‚ïë üî• {user_data['streak']} Day Streak ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n```",
        color=discord.Color.blue()
    )
    embed.add_field(name="üìä Total Earned", value=f"{user_data['total_earned']:,} üíé", inline=True)
    embed.add_field(name="üí∏ Total Spent", value=f"{user_data['total_spent']:,} üíé", inline=True)
    embed.add_field(name="üéÅ Gift Cards", value=f"{len(user_data.get('gift_cards_redeemed', []))}", inline=True)

    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="transfer_points", description="Send points to another user")
async def transfer_points(interaction: discord.Interaction, recipient: discord.Member, amount: int):
    if interaction.channel_id != CHANNELS['transfers']:
        embed = discord.Embed(
            title="‚ùå Wrong Channel",
            description=f"Please use this command in <#{CHANNELS['transfers']}>",
            color=discord.Color.red()
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)
        return

    if amount <= 0:
        await interaction.response.send_message("‚ùå Amount must be positive!", ephemeral=True)
        return

    if recipient.id == interaction.user.id:
        await interaction.response.send_message("‚ùå You can't transfer points to yourself!", ephemeral=True)
        return

    sender_data = points_system.get_user_data(interaction.user.id)

    if sender_data['points'] < amount:
        await interaction.response.send_message(f"‚ùå Insufficient points! You have {sender_data['points']} Diamonds.", ephemeral=True)
        return

    recipient_data = points_system.get_user_data(recipient.id)

    sender_data['points'] -= amount
    sender_data['total_spent'] += amount
    recipient_data['points'] += amount
    recipient_data['total_earned'] += amount

    embed = discord.Embed(
        title="üí∏ Points Transferred!",
        description=f"**3D Transfer Animation:**\n```\n{interaction.user.display_name[:8]}\n    ‚Üì {amount} üíé\n{recipient.display_name[:8]}\n```\nTransfer complete!",
        color=discord.Color.green()
    )

    await interaction.response.send_message(embed=embed)
    await points_system.save_data()

@bot.tree.command(name="gambling_menu", description="Access the 3D gambling menu with all game options")
async def gambling_menu(interaction: discord.Interaction):
    if interaction.channel_id != CHANNELS['gambling']:
        embed = discord.Embed(
            title="‚ùå Wrong Channel",
            description=f"Please use this command in <#{CHANNELS['gambling']}>",
            color=discord.Color.red()
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)
        return

    user_data = points_system.get_user_data(interaction.user.id)

    embed = discord.Embed(
        title="üé∞ 3D Casino Menu",
        description=f"**Welcome to the Diamond Casino!**\n```\n    üé∞ CASINO üé∞\n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n  ‚ïë üé≤  ü™ô  üé∞ ‚ïë\n  ‚ïë Dice Coin Slot ‚ïë\n  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n```\n**Your Balance:** {user_data['points']} üíé\n\nClick a button below to learn about each game!",
        color=discord.Color.purple()
    )

    view = GamblingView()
    await interaction.response.send_message(embed=embed, view=view)

@bot.tree.command(name="redeem_gift_card", description="Convert your diamonds to gift cards")
async def redeem_gift_card(interaction: discord.Interaction):
    user_data = points_system.get_user_data(interaction.user.id)

    embed = discord.Embed(
        title="üéÅ Gift Card Redemption Center",
        description=f"**Your Balance:** {user_data['points']} üíé\n\n**Available Gift Cards:**\n\n```\nüéÅ GIFT CARD STORE üéÅ\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë Choose your reward! ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n```\nSelect a gift card from the dropdown below:",
        color=discord.Color.gold()
    )

    # Show available gift cards
    for card_type, card in GIFT_CARDS.items():
        affordable = "‚úÖ" if user_data['points'] >= card['cost'] else "‚ùå"
        embed.add_field(
            name=f"{card['emoji']} {card['name']}",
            value=f"{affordable} {card['cost']} üíé",
            inline=True
        )

    view = GiftCardView()
    await interaction.response.send_message(embed=embed, view=view)

@bot.tree.command(name="leaderboard", description="View the points leaderboard")
async def leaderboard(interaction: discord.Interaction):
    # Allow leaderboard in both leaderboard channel and general (if set)
    allowed_channels = [CHANNELS['leaderboard']]
    if CHANNELS.get('general'):
        allowed_channels.append(CHANNELS['general'])

    if interaction.channel_id not in allowed_channels:
        embed = discord.Embed(
            title="‚ùå Wrong Channel",
            description=f"Please use this command in <#{CHANNELS['leaderboard']}>" + 
                       (f" or <#{CHANNELS['general']}>" if CHANNELS.get('general') else ""),
            color=discord.Color.red()
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)
        return

    users_data = points_system.data['users']
    sorted_users = sorted(users_data.items(), key=lambda x: x[1]['points'], reverse=True)[:10]

    embed = discord.Embed(
        title="üèÜ 3D Diamond Leaderboard",
        description="**Top 10 Richest Players**\n```\n    üèÜ LEADERBOARD üèÜ\n  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n  ‚ïë üëë DIAMOND ELITE üëë ‚ïë\n  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n```",
        color=discord.Color.gold()
    )

    medals = ["ü•á", "ü•à", "ü•â"]
    trophy_design = ["üëë", "üíé", "‚≠ê"]

    for i, (user_id, data) in enumerate(sorted_users, 1):
        try:
            user = bot.get_user(int(user_id))
            user_display = f"@{user.name}" if user else f"User {user_id}"
        except:
            user_display = f"User {user_id}"

        if i <= 3:
            position_emoji = medals[i-1]
            decoration = trophy_design[i-1]
        else:
            position_emoji = f"{i}."
            decoration = "üíé"

        embed.add_field(
            name=f"{position_emoji} {user_display}",
            value=f"{decoration} {data['points']:,} Diamonds\nüî• {data['streak']} day streak",
            inline=False
        )

    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="drop_points", description="Admin: Start a point drop session")
@commands.has_permissions(administrator=True)
async def drop_points(interaction: discord.Interaction):
    drop_channel = bot.get_channel(CHANNELS['point_drops'])
    if not drop_channel:
        await interaction.response.send_message("‚ùå Point drops channel not found!", ephemeral=True)
        return

    embed = discord.Embed(
        title="‚è≥ Admin Point Drop Starting!",
        description="**3D Drop Preview:**\n```\n     üíéüíéüíé\n    ‚ï± ‚ï≤ ‚ï± ‚ï≤\n   ‚ï±   ‚ï≤   ‚ï≤\n  ‚ï±_____‚ï≤___‚ï≤\n```\nGet ready! Claiming starts in 5 minutes!",
        color=discord.Color.orange()
    )
    embed.set_footer(text=f"Triggered by {interaction.user.display_name}")

    view = PointDropView(timeout=360)
    message = await drop_channel.send(embed=embed, view=view)
    asyncio.create_task(view.start_countdown(message))

    await interaction.response.send_message(f"‚úÖ Point drop session started in <#{CHANNELS['point_drops']}>!", ephemeral=True)

@bot.tree.command(name="send_daily_claim", description="Admin: Manually send daily claim button to channel")
@commands.has_permissions(administrator=True)
async def send_daily_claim(interaction: discord.Interaction):
    daily_channel = bot.get_channel(CHANNELS['daily_claims'])
    if not daily_channel:
        await interaction.response.send_message("‚ùå Daily claims channel not found!", ephemeral=True)
        return

    # Clean old daily claim messages before sending new one
    await cleanup_old_messages(daily_channel, bot.user.id)

    embed = discord.Embed(
        title="üíé Daily Diamond Claim Available!",
        description="**Daily Diamond Reward:**\n```\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë   üíé 50   ‚ïë\n‚ïë  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó  ‚ïë\n‚ïë  ‚ïë ‚ú® ‚ú® ‚ïë  ‚ïë\n‚ïë  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n```\n**Your daily diamonds are ready!**\n\nClick the button below to claim your diamonds and maintain your streak!",
        color=discord.Color.gold()
    )
    embed.add_field(name="üí∞ Base Reward", value="50 üíé", inline=True)
    embed.add_field(name="üî• Streak Bonus", value="Up to 3x multiplier!", inline=True)
    embed.add_field(name="‚è∞ Manual Trigger", value="Admin activated", inline=True)
    embed.set_footer(text=f"Triggered by {interaction.user.display_name}")

    view = DailyClaimView()
    await daily_channel.send(embed=embed, view=view)
    await interaction.response.send_message(f"‚úÖ Daily claim button sent to <#{CHANNELS['daily_claims']}>!", ephemeral=True)

# Run the bot
if __name__ == "__main__":
    bot_token = os.getenv('DISCORD_BOT_TOKEN')
    if not bot_token:
        print("‚ùå Error: DISCORD_BOT_TOKEN not found in environment variables!")
        print("Please add your bot token in the Secrets tab (üîí icon in sidebar)")
        print("Key: DISCORD_BOT_TOKEN")
        print("Value: Your Discord bot token")
        exit(1)

    print("ü§ñ Starting Discord Points Bot...")
    try:
        bot.run(bot_token)
    except Exception as e:
        print(f"‚ùå Failed to start bot: {e}")
        print("Please check your bot token and internet connection.")